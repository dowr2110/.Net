/*Класс  множество Set. Дополнительно перегрузить
следующие операции: ->> удалить элемент из множества
(типа set-item); >  проверка на подмножество; !=  проверка
множеств на неравенство; <<  добавить элемент в множество
(типа set+item); % пересечение множеств.
Методы расширения:
1) Поиск самого короткого слова
2) Упорядочивание множества

 
 set-//заданные перегруженные операции
 StatisticOperation-//методы расширения
 Owner- //который содержит Id, имя и организацию создателя
 */
/*Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор, специального метода:

public static возвращаемый_тип operator оператор(параметры)
{  }
Этот метод должен иметь модификаторы public static, 
так как перегружаемый оператор будет использоваться для всех объектов данного класса.
Далее идет название возвращаемого типа. Возвращаемый тип представляет тот тип, объекты которого мы хотим получить.
К примеру, в результате сложения двух объектов Counter мы ожидаем получить новый объект Counter.
А в результате сравнения двух мы хотим получить объект типа bool, который указывает истинно ли условное выражение или ложно
. Но в зависимости от задачи возвращаемые типы могут быть любыми.

Затем вместо названия метода идет ключевое слово operator и собственно сам оператор. 
И далее в скобках перечисляются параметры. Бинарные операторы принимают два параметра, унарные - один параметр.
И в любом случае один из параметров должен представлять тот тип - класс или структуру, в котором определяется оператор.*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace laba_4
{

    class Program
        {
            static void Main(string[] args)
            {
            /*Написать программу тестирования, в которой проверяется
использование перегруженных операций.*/
            Set s1 = new Set(5);
            Set s2 = new Set(5);
            Set s3;
            Set s4 = new Set(5);
             
            Console.WriteLine($"Дата создания s1: {s1.date}");

            s1.add(345);
            s1.add(123);
            s1.add(123);

            s2.add(123);
            s2.add(456);

            s4.add(123);

            Console.Write("s1 ");
            s1.show();
            Console.Write("s2 ");
            s2.show();

            s3 = s1 % s2;
            Console.Write("s3 ");
            s3.show();

            s1 = s1 >> 123;
            Console.Write("s1 ");
            s1.show();
            s1 = s1 << 789;
            Console.Write("s1 ");
            s1.show();

            int c = s1.MinMax();
            Console.WriteLine(c);
            Console.WriteLine($"s1 == s2: {s1 == s2}");
            Console.WriteLine($"s1 == s1: {s1 == s1}");
            Console.WriteLine($"s1 != s2: {s1 != s2}");
            Console.WriteLine($"s1 > s4: {s1 > s4}");
        }
        }
    }
/* konstruktor- on dayet znaceniya obyektam klassa 
  

 Перегрузка операций,
     перегрузка--Определяемый пользователем тип может перегружать предопределенный оператор C#. 
    То есть тип может указать пользовательскую реализацию операции, когда один или оба операнда принадлежат этому типу.



    +,  -,  !,  ++,  —, true, false	Этот набор унарных операций может быть перегружен
+,  -,  *,  /,  %,  &,  |, ^,  <<,  >>	Эти бинарные операции могут быть перегружены
==,  !=,  <,  >,  <=, >=	Эти операции сравнения могут быть перегружены. C# требует совместной перегрузки «подобных» операций (т.е. <  и  >,  <= и >=,  == и  !=)
[ ]	Операция [] не может быть перегружена. Аналогичную функциональность предлагают индексаторы
( )	Операция () не может быть перегружена, но ту же функциональность предоставляют специальные методы преобразования
+=,  -=,  *=,  /=,  %=,  &=,  |=,  ^=, <<=,  >>=	Сокращенные операции присваивания не могут перегружаться; однако вы получаете их автоматически, перегружая соответствующую бинарную операцию
     
    Перегрузка операторов тесно связана с перегрузкой методов. 
    Для перегрузки оператора служит ключевое слово operator, определяющее операторный метод, который, в свою очередь, 
    определяет действие оператора относительно своего класса. Существуют две формы операторных методов:
    одна — для унарных операторов, другая — для бинарных


    Собственно метод расширения - это обычный статический метод, который в качестве первого параметра всегда принимает такую конструкцию:
    this имя_типа название_параметра, то есть в нашем случае this string str.
    Так как наш метод будет относиться к типу string, то мы и используем данный тип.


    вложенные типы--Тип, определенный внутри класса или структуры, называется вложенным типом

     Индексаторы позволяют индексировать экземпляры класса ???????????????*/






